use anyhow::{Context, Result};
use itertools::Itertools;
use std::collections::{HashMap, VecDeque};

fn parse_line(s: &str) -> Result<(String, Vec<String>)> {
    let mut split = s.split(": ");
    let id = split.next().context("Could not read id")?.to_string();
    let next = split
        .next()
        .context("Could not read connections")?
        .split(' ')
        .map(|i| i.to_string())
        .collect_vec();

    Ok((id, next))
}

#[aoc_generator(day25)]
pub fn input_generator(input: &str) -> Result<HashMap<String, Vec<String>>> {
    input
        .lines()
        .filter(|s| !s.is_empty())
        .map(parse_line)
        .collect::<Result<HashMap<String, Vec<String>>>>()
        .context("Error while parsing input")
}

#[allow(dead_code)]
fn to_digraph(map: &HashMap<String, Vec<String>>) {
    println!("digraph {{");
    for (id, next) in map {
        for n in next {
            println!("{} -> {}", id, n);
        }
    }
    println!("}}");
}

fn subgraph_size(map: &HashMap<String, Vec<String>>, start: &str) -> usize {
    let mut visited = vec![];
    let mut queue = VecDeque::new();
    queue.push_back(start.to_string());

    while let Some(q) = queue.pop_front() {
        if visited.contains(&q) {
            continue;
        }

        visited.push(q.clone());

        for (k, v) in map {
            if k == &q {
                for n in v {
                    queue.push_back(n.to_string());
                }
            }

            if v.contains(&q) {
                queue.push_back(k.to_string());
            }
        }
    }

    visited.len()
}

#[aoc(day25, part1)]
pub fn solve_part1(input: &HashMap<String, Vec<String>>) -> Result<usize> {
    // determined by looking at a plot of the graph generated by pushing the output
    // of to_digraph() into graphviz and looking at it in inkscape
    let delete = if input.len() == 13 {
        [("pzl", "hfx"), ("cmg", "bvb"), ("jqt", "nvd")]
    } else {
        [("fhv", "zsp"), ("bqp", "fqr"), ("hcd", "cnr")]
    };

    let mut map = input.clone();

    for d in delete.iter() {
        map.entry(d.0.to_string())
            .and_modify(|v: &mut Vec<String>| {
                if let Some(pos) = v.iter().find_position(|e| *e == d.1) {
                    v.remove(pos.0);
                }
            });
    }

    let size1 = subgraph_size(&map, delete[1].0);
    let size2 = subgraph_size(&map, delete[1].1);

    Ok(size1 * size2)
}

#[aoc(day25, part2)]
pub fn solve_part2(_input: &HashMap<String, Vec<String>>) -> Result<u32> {
    Ok(0)
}

#[cfg(test)]
mod test {
    use super::*;

    fn sample() -> &'static str {
    "jqt: rhn xhk nvd
rsh: frs pzl lsr
xhk: hfx
cmg: qnr nvd lhk bvb
rhn: xhk bvb hfx
bvb: xhk hfx
pzl: lsr hfx nvd
qnr: nvd
ntq: jqt hfx bvb xhk
nvd: lhk
lsr: lhk
rzs: qnr cmg lsr rsh
frs: qnr lhk lsr"
    }

    fn input() -> Result<HashMap<String, Vec<String>>> {
        input_generator(sample())
    }

    #[test]
    fn part1_sample() -> Result<()> {
        let data = input()?;
        Ok(assert_eq!(54, solve_part1(&data)?))
    }

    #[test]
    fn part2_sample() -> Result<()> {
        let data = input()?;
        Ok(assert_eq!(0, solve_part2(&data)?))
    }
}
